
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Tattsum/quiz/internal/handlers/auth.go (0.0%)</option>
				
				<option value="file1">github.com/Tattsum/quiz/internal/handlers/helpers.go (69.4%)</option>
				
				<option value="file2">github.com/Tattsum/quiz/internal/handlers/participant.go (65.4%)</option>
				
				<option value="file3">github.com/Tattsum/quiz/internal/handlers/quiz.go (81.0%)</option>
				
				<option value="file4">github.com/Tattsum/quiz/internal/handlers/results.go (13.2%)</option>
				
				<option value="file5">github.com/Tattsum/quiz/internal/handlers/session.go (0.0%)</option>
				
				<option value="file6">github.com/Tattsum/quiz/internal/handlers/test_helper.go (92.9%)</option>
				
				<option value="file7">github.com/Tattsum/quiz/internal/handlers/upload.go (0.0%)</option>
				
				<option value="file8">github.com/Tattsum/quiz/internal/handlers/websocket.go (68.6%)</option>
				
				<option value="file9">github.com/Tattsum/quiz/internal/services/auth_service.go (23.4%)</option>
				
				<option value="file10">github.com/Tattsum/quiz/internal/services/image_service.go (72.1%)</option>
				
				<option value="file11">github.com/Tattsum/quiz/internal/services/jwt_service.go (81.5%)</option>
				
				<option value="file12">github.com/Tattsum/quiz/internal/services/quiz_service.go (19.0%)</option>
				
				<option value="file13">github.com/Tattsum/quiz/internal/services/s3_storage.go (0.0%)</option>
				
				<option value="file14">github.com/Tattsum/quiz/internal/services/storage.go (48.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package handlers provides HTTP handlers for the quiz application API endpoints.
package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/Tattsum/quiz/internal/middleware"
        "github.com/Tattsum/quiz/internal/models"
        "github.com/Tattsum/quiz/internal/services"
)

// AdminLogin handles admin login with JWT token generation
func AdminLogin(c *gin.Context) <span class="cov0" title="0">{
        var req models.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: "Invalid request data",
                                Details: parseValidationErrors(err),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">authService := services.NewAuthService()
        jwtService := services.NewJWTService()

        // Authenticate user
        admin, err := authService.AuthenticateAdmin(req.Username, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "INVALID_CREDENTIALS",
                                Message: "Invalid username or password",
                        },
                })
                return
        }</span>

        // Generate JWT token pair
        <span class="cov0" title="0">response, err := jwtService.GenerateTokenPair(admin)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "TOKEN_GENERATION_ERROR",
                                Message: "Failed to generate authentication tokens",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Message: "ログインに成功しました",
                Data:    response,
        })</span>
}

// AdminLogout handles admin logout
func AdminLogout(c *gin.Context) <span class="cov0" title="0">{
        // Get token from context (set by JWT middleware)
        token, exists := c.Get("token")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "MISSING_TOKEN",
                                Message: "Token not found in request",
                        },
                })
                return
        }</span>

        // Add token to blacklist
        <span class="cov0" title="0">middleware.BlacklistToken(token.(string))

        c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Message: "ログアウトしました",
        })</span>
}

// RefreshToken handles token refresh
func RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        var req models.RefreshTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: "Invalid request data",
                                Details: parseValidationErrors(err),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">jwtService := services.NewJWTService()
        authService := services.NewAuthService()

        // Validate refresh token
        claims, err := jwtService.ValidateRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                var errorCode, errorMessage string
                switch err </span>{
                case services.ErrExpiredToken:<span class="cov0" title="0">
                        errorCode = "REFRESH_TOKEN_EXPIRED"
                        errorMessage = "Refresh token has expired"</span>
                case services.ErrInvalidTokenType:<span class="cov0" title="0">
                        errorCode = "INVALID_TOKEN_TYPE"
                        errorMessage = "Invalid token type"</span>
                default:<span class="cov0" title="0">
                        errorCode = "INVALID_REFRESH_TOKEN"
                        errorMessage = "Invalid refresh token"</span>
                }

                <span class="cov0" title="0">c.JSON(http.StatusUnauthorized, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    errorCode,
                                Message: errorMessage,
                        },
                })
                return</span>
        }

        // Get admin details
        <span class="cov0" title="0">admin, err := authService.GetAdminByID(claims.AdminID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "ADMIN_NOT_FOUND",
                                Message: "Admin user not found",
                        },
                })
                return
        }</span>

        // Generate new token pair
        <span class="cov0" title="0">response, err := jwtService.RefreshTokens(req.RefreshToken, admin)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "TOKEN_REFRESH_ERROR",
                                Message: "Failed to refresh tokens",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Message: "トークンを更新しました",
                Data:    response,
        })</span>
}

// VerifyToken verifies the current JWT token
func VerifyToken(c *gin.Context) <span class="cov0" title="0">{
        // Get admin info from context (set by JWT middleware)
        adminID, _ := c.Get("admin_id")
        username, _ := c.Get("username")

        authService := services.NewAuthService()
        admin, err := authService.GetAdminByID(adminID.(int64))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "ADMIN_NOT_FOUND",
                                Message: "Admin user not found",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "valid": true,
                        "admin": admin,
                        "context": map[string]interface{}{
                                "admin_id": adminID,
                                "username": username,
                        },
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "strconv"
        "strings"

        "github.com/Tattsum/quiz/internal/models"
        "github.com/gin-gonic/gin"
        validator "github.com/go-playground/validator/v10"
)

// parseValidationErrors converts validation errors to API error format
func parseValidationErrors(err error) []models.ValidationError <span class="cov6" title="9">{
        var errors []models.ValidationError

        if validationErrors, ok := err.(validator.ValidationErrors); ok </span><span class="cov5" title="6">{
                for _, e := range validationErrors </span><span class="cov7" title="11">{
                        errors = append(errors, models.ValidationError{
                                Field:   getFieldName(e.Tag(), e.Field()),
                                Message: getValidationMessage(e),
                        })
                }</span>
        }

        <span class="cov6" title="9">return errors</span>
}

// getFieldName returns user-friendly field name
func getFieldName(_ /*tag*/, field string) string <span class="cov7" title="11">{
        // Convert field names to user-friendly format
        switch strings.ToLower(field) </span>{
        case "username":<span class="cov0" title="0">
                return "ユーザー名"</span>
        case "password":<span class="cov0" title="0">
                return "パスワード"</span>
        case "nickname":<span class="cov2" title="2">
                return "ニックネーム"</span>
        case "questiontext":<span class="cov1" title="1">
                return "問題文"</span>
        case "optiona", "optionb", "optionc", "optiond":<span class="cov4" title="4">
                return "選択肢"</span>
        case "correctanswer":<span class="cov1" title="1">
                return "正解"</span>
        case "participantid":<span class="cov1" title="1">
                return "参加者ID"</span>
        case "quizid":<span class="cov0" title="0">
                return "問題ID"</span>
        case "selectedoption":<span class="cov2" title="2">
                return "選択した答え"</span>
        default:<span class="cov0" title="0">
                return field</span>
        }
}

// getValidationMessage returns user-friendly validation message
func getValidationMessage(err validator.FieldError) string <span class="cov7" title="11">{
        switch err.Tag() </span>{
        case "required":<span class="cov6" title="8">
                return "必須項目です"</span>
        case "max":<span class="cov1" title="1">
                return "文字数が上限を超えています"</span>
        case "min":<span class="cov0" title="0">
                return "文字数が不足しています"</span>
        case "oneof":<span class="cov2" title="2">
                return "有効な値を選択してください"</span>
        case "email":<span class="cov0" title="0">
                return "有効なメールアドレスを入力してください"</span>
        default:<span class="cov0" title="0">
                return "入力値が不正です"</span>
        }
}

// getPaginationParams extracts pagination parameters from query
func getPaginationParams(c *gin.Context) (int, int, error) <span class="cov2" title="2">{
        pageStr := c.DefaultQuery("page", "1")
        limitStr := c.DefaultQuery("limit", "20")

        page, err := strconv.Atoi(pageStr)
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov2" title="2">limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt; 1 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov2" title="2">return page, limit, nil</span>
}

// convertQuizToPublic converts Quiz model to QuizPublic (without correct answer)
func convertQuizToPublic(quiz models.Quiz) models.QuizPublic <span class="cov0" title="0">{
        return models.QuizPublic{
                ID:           quiz.ID,
                QuestionText: quiz.QuestionText,
                OptionA:      quiz.OptionA,
                OptionB:      quiz.OptionB,
                OptionC:      quiz.OptionC,
                OptionD:      quiz.OptionD,
                ImageURL:     quiz.ImageURL,
                VideoURL:     quiz.VideoURL,
        }
}</span>

// calculatePercentage calculates percentage with proper rounding
func calculatePercentage(part, total int) float64 <span class="cov10" title="30">{
        if total == 0 </span><span class="cov10" title="30">{
                return 0
        }</span>
        <span class="cov0" title="0">return float64(part) / float64(total) * 100</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "strconv"

        "github.com/Tattsum/quiz/internal/database"
        "github.com/Tattsum/quiz/internal/models"
        "github.com/gin-gonic/gin"
)

// RegisterParticipant registers a new participant
func RegisterParticipant(c *gin.Context) <span class="cov10" title="4">{
        var req models.ParticipantRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="3">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: "Invalid request data",
                                Details: parseValidationErrors(err),
                        },
                })
                return
        }</span>

        <span class="cov1" title="1">db := database.GetDB()

        // Insert new participant
        query := `INSERT INTO participants (nickname, created_at)
                          VALUES ($1, CURRENT_TIMESTAMP)
                          RETURNING id, created_at`

        var participant models.Participant
        err := db.QueryRow(query, req.Nickname).Scan(&amp;participant.ID, &amp;participant.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to register participant",
                        },
                })
                return
        }</span>

        <span class="cov1" title="1">participant.Nickname = req.Nickname

        c.JSON(http.StatusCreated, models.APIResponse{
                Success: true,
                Message: "参加者として登録されました",
                Data: map[string]interface{}{
                        "participant_id": participant.ID,
                        "nickname":       participant.Nickname,
                        "created_at":     participant.CreatedAt,
                },
        })</span>
}

// GetParticipant retrieves participant information
func GetParticipant(c *gin.Context) <span class="cov8" title="3">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "INVALID_ID",
                                Message: "Invalid participant ID",
                        },
                })
                return
        }</span>

        <span class="cov5" title="2">db := database.GetDB()

        // Get participant basic info
        var participant models.Participant
        participantQuery := `SELECT id, nickname, created_at FROM participants WHERE id = $1`

        err = db.QueryRow(participantQuery, id).Scan(
                &amp;participant.ID,
                &amp;participant.Nickname,
                &amp;participant.CreatedAt,
        )
        if err != nil </span><span class="cov1" title="1">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "PARTICIPANT_NOT_FOUND",
                                        Message: "Participant not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to query participant",
                        },
                })
                return</span>
        }

        // Get participant statistics
        <span class="cov1" title="1">var totalAnswers, correctAnswers int
        statsQuery := `SELECT COUNT(*), COALESCE(SUM(CASE WHEN is_correct THEN 1 ELSE 0 END), 0)
                                   FROM answers WHERE participant_id = $1`

        err = db.QueryRow(statsQuery, id).Scan(&amp;totalAnswers, &amp;correctAnswers)
        if err != nil </span><span class="cov0" title="0">{
                // If error getting stats, just return basic info
                totalAnswers = 0
                correctAnswers = 0
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Data: map[string]interface{}{
                        "id":              participant.ID,
                        "nickname":        participant.Nickname,
                        "created_at":      participant.CreatedAt,
                        "total_answers":   totalAnswers,
                        "correct_answers": correctAnswers,
                },
        })</span>
}

// GetParticipantAnswers retrieves participant's answer history
func GetParticipantAnswers(c *gin.Context) <span class="cov8" title="3">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "INVALID_ID",
                                Message: "Invalid participant ID",
                        },
                })
                return
        }</span>

        <span class="cov5" title="2">db := database.GetDB()

        // Check if participant exists
        var participantID int64
        err = db.QueryRow("SELECT id FROM participants WHERE id = $1", id).Scan(&amp;participantID)
        if err != nil </span><span class="cov1" title="1">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "PARTICIPANT_NOT_FOUND",
                                        Message: "Participant not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to check participant",
                        },
                })
                return</span>
        }

        // Get participant answers with quiz details
        <span class="cov1" title="1">answersQuery := `SELECT a.id, a.quiz_id, q.question_text, a.selected_option, 
                                         q.correct_answer, a.is_correct, a.answered_at
                                         FROM answers a
                                         JOIN quizzes q ON a.quiz_id = q.id
                                         WHERE a.participant_id = $1
                                         ORDER BY a.answered_at DESC`

        rows, err := db.Query(answersQuery, id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to query answers",
                        },
                })
                return
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                _ = rows.Close() // Ignore close error in defer
        }</span>()

        <span class="cov1" title="1">var answers []models.ParticipantAnswer
        for rows.Next() </span><span class="cov0" title="0">{
                var answer models.ParticipantAnswer
                err := rows.Scan(
                        &amp;answer.AnswerID,
                        &amp;answer.QuizID,
                        &amp;answer.QuestionText,
                        &amp;answer.SelectedOption,
                        &amp;answer.CorrectAnswer,
                        &amp;answer.IsCorrect,
                        &amp;answer.AnsweredAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "SCAN_ERROR",
                                        Message: "Failed to scan answer data",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">answers = append(answers, answer)</span>
        }

        // Calculate statistics
        <span class="cov1" title="1">totalAnswers := len(answers)
        correctAnswers := 0
        for _, answer := range answers </span><span class="cov0" title="0">{
                if answer.IsCorrect </span><span class="cov0" title="0">{
                        correctAnswers++
                }</span>
        }

        <span class="cov1" title="1">var accuracyRate float64
        if totalAnswers &gt; 0 </span><span class="cov0" title="0">{
                accuracyRate = float64(correctAnswers) / float64(totalAnswers)
        }</span>

        <span class="cov1" title="1">response := models.ParticipantAnswersResponse{
                ParticipantID:  id,
                Answers:        answers,
                TotalAnswers:   totalAnswers,
                CorrectAnswers: correctAnswers,
                AccuracyRate:   accuracyRate,
        }

        c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Data:    response,
        })</span>
}

// SubmitAnswer handles answer submission
//
//nolint:gocyclo
func SubmitAnswer(c *gin.Context) <span class="cov10" title="4">{
        var req models.AnswerRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="3">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: "Invalid request data",
                                Details: parseValidationErrors(err),
                        },
                })
                return
        }</span>

        <span class="cov1" title="1">db := database.GetDB()

        // Check if session is accepting answers
        var isAcceptingAnswers bool
        var currentQuizID *int64
        sessionQuery := `SELECT is_accepting_answers, current_quiz_id 
                                         FROM quiz_sessions 
                                         ORDER BY id DESC 
                                         LIMIT 1`

        err := db.QueryRow(sessionQuery).Scan(&amp;isAcceptingAnswers, &amp;currentQuizID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "SESSION_ERROR",
                                Message: "No active session found",
                        },
                })
                return
        }</span>

        <span class="cov1" title="1">if !isAcceptingAnswers </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "ANSWERS_NOT_ACCEPTED",
                                Message: "Answer submission is currently not accepted",
                        },
                })
                return
        }</span>

        <span class="cov1" title="1">if currentQuizID == nil || *currentQuizID != req.QuizID </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "INVALID_QUIZ",
                                Message: "This quiz is not currently active",
                        },
                })
                return
        }</span>

        // Check if participant exists
        <span class="cov1" title="1">var participantID int64
        err = db.QueryRow("SELECT id FROM participants WHERE id = $1", req.ParticipantID).Scan(&amp;participantID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "PARTICIPANT_NOT_FOUND",
                                        Message: "Participant not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to check participant",
                        },
                })
                return</span>
        }

        // Get quiz correct answer
        <span class="cov1" title="1">var correctAnswer string
        err = db.QueryRow("SELECT correct_answer FROM quizzes WHERE id = $1", req.QuizID).Scan(&amp;correctAnswer)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "QUIZ_NOT_FOUND",
                                        Message: "Quiz not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to get quiz",
                        },
                })
                return</span>
        }

        <span class="cov1" title="1">isCorrect := req.SelectedOption == correctAnswer

        // Check if answer already exists (for update)
        var existingAnswerID int64
        checkQuery := `SELECT id FROM answers WHERE participant_id = $1 AND quiz_id = $2`
        err = db.QueryRow(checkQuery, req.ParticipantID, req.QuizID).Scan(&amp;existingAnswerID)

        if err == nil </span><span class="cov0" title="0">{
                // Update existing answer
                updateQuery := `UPDATE answers 
                                                SET selected_option = $1, is_correct = $2, answered_at = CURRENT_TIMESTAMP
                                                WHERE id = $3
                                                RETURNING id, answered_at`

                var answer models.Answer
                err = db.QueryRow(updateQuery, req.SelectedOption, isCorrect, existingAnswerID).Scan(
                        &amp;answer.ID, &amp;answer.AnsweredAt)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "DATABASE_ERROR",
                                        Message: "Failed to update answer",
                                },
                        })
                        return
                }</span>

                <span class="cov0" title="0">answer.ParticipantID = req.ParticipantID
                answer.QuizID = req.QuizID
                answer.SelectedOption = req.SelectedOption
                answer.IsCorrect = isCorrect

                // Broadcast answer status update
                db := database.GetDB()
                var totalParticipants, answeredCount int
                answerCounts := make(map[string]int)

                // Get total participants
                _ = db.QueryRow("SELECT COUNT(*) FROM participants").Scan(&amp;totalParticipants)

                // Get answered count for this quiz
                _ = db.QueryRow("SELECT COUNT(*) FROM answers WHERE quiz_id = $1", req.QuizID).Scan(&amp;answeredCount)

                // Get answer distribution
                rows, err := db.Query("SELECT selected_option, COUNT(*) FROM answers WHERE quiz_id = $1 GROUP BY selected_option", req.QuizID)
                if err == nil </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                _ = rows.Close() // Ignore close error in defer
                        }</span>()
                        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                                var option string
                                var count int
                                _ = rows.Scan(&amp;option, &amp;count)
                                answerCounts[option] = count
                        }</span>
                }

                // Broadcast the current answer status
                <span class="cov0" title="0">BroadcastAnswerStatus(req.QuizID, req.QuizID, totalParticipants, answeredCount, answerCounts)

                c.JSON(http.StatusOK, models.APIResponse{
                        Success: true,
                        Message: "回答が変更されました",
                        Data:    answer,
                })</span>
        } else<span class="cov1" title="1"> if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                // Insert new answer
                insertQuery := `INSERT INTO answers (participant_id, quiz_id, selected_option, is_correct, answered_at)
                                                VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)
                                                RETURNING id, answered_at`

                var answer models.Answer
                err = db.QueryRow(insertQuery, req.ParticipantID, req.QuizID, req.SelectedOption, isCorrect).Scan(
                        &amp;answer.ID, &amp;answer.AnsweredAt)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "DATABASE_ERROR",
                                        Message: "Failed to submit answer",
                                },
                        })
                        return
                }</span>

                <span class="cov1" title="1">answer.ParticipantID = req.ParticipantID
                answer.QuizID = req.QuizID
                answer.SelectedOption = req.SelectedOption
                answer.IsCorrect = isCorrect

                // Broadcast answer status update
                db := database.GetDB()
                var totalParticipants, answeredCount int
                answerCounts := make(map[string]int)

                // Get total participants
                _ = db.QueryRow("SELECT COUNT(*) FROM participants").Scan(&amp;totalParticipants)

                // Get answered count for this quiz
                _ = db.QueryRow("SELECT COUNT(*) FROM answers WHERE quiz_id = $1", req.QuizID).Scan(&amp;answeredCount)

                // Get answer distribution
                rows, err := db.Query("SELECT selected_option, COUNT(*) FROM answers WHERE quiz_id = $1 GROUP BY selected_option", req.QuizID)
                if err == nil </span><span class="cov1" title="1">{
                        defer func() </span><span class="cov1" title="1">{
                                _ = rows.Close() // Ignore close error in defer
                        }</span>()
                        <span class="cov1" title="1">for rows.Next() </span><span class="cov1" title="1">{
                                var option string
                                var count int
                                _ = rows.Scan(&amp;option, &amp;count)
                                answerCounts[option] = count
                        }</span>
                }

                // Broadcast the current answer status
                <span class="cov1" title="1">BroadcastAnswerStatus(req.QuizID, req.QuizID, totalParticipants, answeredCount, answerCounts)

                c.JSON(http.StatusCreated, models.APIResponse{
                        Success: true,
                        Message: "回答が送信されました",
                        Data:    answer,
                })</span>
        } else<span class="cov0" title="0"> {
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to check existing answer",
                        },
                })
                return
        }</span>
}

// UpdateAnswer handles answer updates
func UpdateAnswer(c *gin.Context) <span class="cov10" title="4">{
        idStr := c.Param("id")
        answerID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "INVALID_ID",
                                Message: "Invalid answer ID",
                        },
                })
                return
        }</span>

        <span class="cov8" title="3">var req models.AnswerUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: "Invalid request data",
                                Details: parseValidationErrors(err),
                        },
                })
                return
        }</span>

        <span class="cov5" title="2">db := database.GetDB()

        // Check if session is accepting answers
        var isAcceptingAnswers bool
        sessionQuery := `SELECT is_accepting_answers FROM quiz_sessions ORDER BY id DESC LIMIT 1`
        err = db.QueryRow(sessionQuery).Scan(&amp;isAcceptingAnswers)
        if err != nil || !isAcceptingAnswers </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "ANSWERS_NOT_ACCEPTED",
                                Message: "Answer updates are not currently accepted",
                        },
                })
                return
        }</span>

        // Get existing answer and quiz info
        <span class="cov5" title="2">var quizID int64
        var correctAnswer string
        existingQuery := `SELECT a.quiz_id, q.correct_answer 
                                          FROM answers a 
                                          JOIN quizzes q ON a.quiz_id = q.id 
                                          WHERE a.id = $1`

        err = db.QueryRow(existingQuery, answerID).Scan(&amp;quizID, &amp;correctAnswer)
        if err != nil </span><span class="cov1" title="1">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "ANSWER_NOT_FOUND",
                                        Message: "Answer not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to get answer",
                        },
                })
                return</span>
        }

        <span class="cov1" title="1">isCorrect := req.SelectedOption == correctAnswer

        // Update answer
        updateQuery := `UPDATE answers 
                                        SET selected_option = $1, is_correct = $2, answered_at = CURRENT_TIMESTAMP
                                        WHERE id = $3
                                        RETURNING participant_id, quiz_id, answered_at`

        var answer models.Answer
        err = db.QueryRow(updateQuery, req.SelectedOption, isCorrect, answerID).Scan(
                &amp;answer.ParticipantID, &amp;answer.QuizID, &amp;answer.AnsweredAt)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to update answer",
                        },
                })
                return
        }</span>

        <span class="cov1" title="1">answer.ID = answerID
        answer.SelectedOption = req.SelectedOption
        answer.IsCorrect = isCorrect

        c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Message: "回答が変更されました",
                Data:    answer,
        })</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "github.com/Tattsum/quiz/internal/models"
        "github.com/Tattsum/quiz/internal/services"
        "github.com/gin-gonic/gin"
)

const quizNotFoundError = "quiz not found"

// GetQuizzes retrieves all quizzes with pagination
func GetQuizzes(c *gin.Context) <span class="cov6" title="2">{
        page, limit, _ := getPaginationParams(c)

        quizService := services.NewQuizService()
        quizzes, total, err := quizService.GetQuizzes(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to retrieve quizzes",
                        },
                })
                return
        }</span>

        <span class="cov6" title="2">c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Data: models.PaginatedResponse{
                        Data:  quizzes,
                        Total: total,
                        Page:  page,
                        Limit: limit,
                },
        })</span>
}

// GetQuiz retrieves a single quiz by ID
func GetQuiz(c *gin.Context) <span class="cov10" title="3">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "INVALID_ID",
                                Message: "Invalid quiz ID",
                        },
                })
                return
        }</span>

        <span class="cov6" title="2">quizService := services.NewQuizService()
        quiz, err := quizService.GetQuizByID(id)
        if err != nil </span><span class="cov1" title="1">{
                if err.Error() == quizNotFoundError </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "QUIZ_NOT_FOUND",
                                        Message: "Quiz not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to query quiz",
                        },
                })
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Data:    quiz,
        })</span>
}

// CreateQuiz creates a new quiz
func CreateQuiz(c *gin.Context) <span class="cov10" title="3">{
        var req models.QuizRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov6" title="2">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: "Invalid request data",
                                Details: parseValidationErrors(err),
                        },
                })
                return
        }</span>

        <span class="cov1" title="1">quizService := services.NewQuizService()
        quiz, err := quizService.CreateQuiz(req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: err.Error(),
                        },
                })
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusCreated, models.APIResponse{
                Success: true,
                Message: "問題が作成されました",
                Data:    quiz,
        })</span>
}

// UpdateQuiz updates an existing quiz
func UpdateQuiz(c *gin.Context) <span class="cov10" title="3">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "INVALID_ID",
                                Message: "Invalid quiz ID",
                        },
                })
                return
        }</span>

        <span class="cov6" title="2">var req models.QuizRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: "Invalid request data",
                                Details: parseValidationErrors(err),
                        },
                })
                return
        }</span>

        <span class="cov6" title="2">quizService := services.NewQuizService()
        quiz, err := quizService.UpdateQuiz(id, req)
        if err != nil </span><span class="cov1" title="1">{
                if err.Error() == quizNotFoundError </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "QUIZ_NOT_FOUND",
                                        Message: "Quiz not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: err.Error(),
                        },
                })
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Message: "問題が更新されました",
                Data:    quiz,
        })</span>
}

// DeleteQuiz deletes a quiz by ID
func DeleteQuiz(c *gin.Context) <span class="cov10" title="3">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "INVALID_ID",
                                Message: "Invalid quiz ID",
                        },
                })
                return
        }</span>

        <span class="cov6" title="2">quizService := services.NewQuizService()
        err = quizService.DeleteQuiz(id)
        if err != nil </span><span class="cov1" title="1">{
                if err.Error() == quizNotFoundError </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "QUIZ_NOT_FOUND",
                                        Message: "Quiz not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to delete quiz",
                        },
                })
                return</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Message: "問題が削除されました",
        })</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "strconv"
        "time"

        "github.com/Tattsum/quiz/internal/database"
        "github.com/Tattsum/quiz/internal/models"
        "github.com/gin-gonic/gin"
)

// GetCurrentResults returns results for the current active quiz
func GetCurrentResults(c *gin.Context) <span class="cov0" title="0">{
        db := database.GetDB()

        // Get current session
        var currentQuizID *int64
        var isAcceptingAnswers bool
        sessionQuery := `SELECT current_quiz_id, is_accepting_answers 
                                         FROM quiz_sessions 
                                         ORDER BY id DESC 
                                         LIMIT 1`

        err := db.QueryRow(sessionQuery).Scan(&amp;currentQuizID, &amp;isAcceptingAnswers)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "NO_ACTIVE_SESSION",
                                Message: "No active session found",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">if currentQuizID == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "NO_CURRENT_QUIZ",
                                Message: "No current quiz in session",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">results, err := getQuizResultsData(db, *currentQuizID, &amp;isAcceptingAnswers)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to get quiz results",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Data:    results,
        })</span>
}

// GetQuizResults returns results for a specific quiz
func GetQuizResults(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        quizID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "INVALID_ID",
                                Message: "Invalid quiz ID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">db := database.GetDB()

        results, err := getQuizResultsData(db, quizID, nil)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "QUIZ_NOT_FOUND",
                                        Message: "Quiz not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to get quiz results",
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Data:    results,
        })</span>
}

// getQuizResultsData retrieves and calculates quiz results
func getQuizResultsData(db *sql.DB, quizID int64, isAcceptingAnswers *bool) (*models.QuizResultsResponse, error) <span class="cov8" title="13">{
        // Get quiz info
        var questionText, correctAnswer string
        quizQuery := `SELECT question_text, correct_answer FROM quizzes WHERE id = $1`
        err := db.QueryRow(quizQuery, quizID).Scan(&amp;questionText, &amp;correctAnswer)
        if err != nil </span><span class="cov6" title="7">{
                return nil, err
        }</span>

        // Get answer counts by option
        <span class="cov6" title="6">resultsQuery := `SELECT selected_option, COUNT(*) 
                                         FROM answers 
                                         WHERE quiz_id = $1 
                                         GROUP BY selected_option`

        rows, err := db.Query(resultsQuery, quizID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="6">defer func() </span><span class="cov6" title="6">{
                _ = rows.Close() // Ignore close error in defer
        }</span>()

        <span class="cov6" title="6">optionCounts := make(map[string]int)
        totalAnswers := 0

        for rows.Next() </span><span class="cov0" title="0">{
                var option string
                var count int
                if err := rows.Scan(&amp;option, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">optionCounts[option] = count
                totalAnswers += count</span>
        }

        // Calculate results for each option
        <span class="cov6" title="6">results := make(map[string]models.OptionResult)
        for _, option := range []string{"A", "B", "C", "D"} </span><span class="cov10" title="24">{
                count := optionCounts[option]
                percentage := calculatePercentage(count, totalAnswers)
                results[option] = models.OptionResult{
                        Count:      count,
                        Percentage: percentage,
                }
        }</span>

        // Get correct answer count
        <span class="cov6" title="6">correctCount := optionCounts[correctAnswer]
        correctPercentage := calculatePercentage(correctCount, totalAnswers)

        response := &amp;models.QuizResultsResponse{
                QuizID:             quizID,
                QuestionText:       questionText,
                TotalAnswers:       totalAnswers,
                Results:            results,
                CorrectAnswer:      correctAnswer,
                CorrectCount:       correctCount,
                CorrectPercentage:  correctPercentage,
                IsAcceptingAnswers: isAcceptingAnswers,
                UpdatedAt:          time.Now(),
        }

        return response, nil</span>
}

// GetOverallRanking returns overall participant ranking
func GetOverallRanking(c *gin.Context) <span class="cov0" title="0">{
        limitStr := c.DefaultQuery("limit", "100")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt; 1 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">db := database.GetDB()

        // Get total participants count
        var totalParticipants int
        err = db.QueryRow("SELECT COUNT(*) FROM participants").Scan(&amp;totalParticipants)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to count participants",
                        },
                })
                return
        }</span>

        // Get ranking data
        <span class="cov0" title="0">rankingQuery := `SELECT p.id, p.nickname,
                                         COUNT(a.id) as total_answers,
                                         COALESCE(SUM(CASE WHEN a.is_correct THEN 1 ELSE 0 END), 0) as correct_answers,
                                         CASE 
                                                WHEN COUNT(a.id) &gt; 0 THEN 
                                                        CAST(SUM(CASE WHEN a.is_correct THEN 1 ELSE 0 END) AS FLOAT) / COUNT(a.id)
                                                ELSE 0 
                                         END as accuracy_rate,
                                         COALESCE(SUM(CASE WHEN a.is_correct THEN 1 ELSE 0 END), 0) as total_score
                                         FROM participants p
                                         LEFT JOIN answers a ON p.id = a.participant_id
                                         GROUP BY p.id, p.nickname
                                         ORDER BY total_score DESC, accuracy_rate DESC, total_answers DESC
                                         LIMIT $1 OFFSET $2`

        rows, err := db.Query(rankingQuery, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to query ranking",
                        },
                })
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = rows.Close() // Ignore close error in defer
        }</span>()

        <span class="cov0" title="0">var ranking []models.RankingEntry
        rank := offset + 1

        for rows.Next() </span><span class="cov0" title="0">{
                var entry models.RankingEntry
                err := rows.Scan(
                        &amp;entry.ParticipantID,
                        &amp;entry.Nickname,
                        &amp;entry.TotalAnswers,
                        &amp;entry.CorrectAnswers,
                        &amp;entry.AccuracyRate,
                        &amp;entry.TotalScore,
                )
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "SCAN_ERROR",
                                        Message: "Failed to scan ranking data",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">entry.Rank = rank
                ranking = append(ranking, entry)
                rank++</span>
        }

        <span class="cov0" title="0">response := models.OverallRankingResponse{
                Ranking:           ranking,
                TotalParticipants: totalParticipants,
                UpdatedAt:         time.Now(),
        }

        c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Data:    response,
        })</span>
}

// GetQuizRanking returns ranking for a specific quiz (correct answers)
func GetQuizRanking(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        quizID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "INVALID_ID",
                                Message: "Invalid quiz ID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">db := database.GetDB()

        // Get quiz info
        var questionText string
        quizQuery := `SELECT question_text FROM quizzes WHERE id = $1`
        err = db.QueryRow(quizQuery, quizID).Scan(&amp;questionText)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "QUIZ_NOT_FOUND",
                                        Message: "Quiz not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to get quiz",
                        },
                })
                return</span>
        }

        // Get correct participants
        <span class="cov0" title="0">correctParticipantsQuery := `SELECT p.id, p.nickname, a.selected_option, a.answered_at
                                                                 FROM answers a
                                                                 JOIN participants p ON a.participant_id = p.id
                                                                 WHERE a.quiz_id = $1 AND a.is_correct = true
                                                                 ORDER BY a.answered_at ASC`

        rows, err := db.Query(correctParticipantsQuery, quizID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to query correct participants",
                        },
                })
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = rows.Close() // Ignore close error in defer
        }</span>()

        <span class="cov0" title="0">var correctParticipants []models.CorrectParticipant
        for rows.Next() </span><span class="cov0" title="0">{
                var participant models.CorrectParticipant
                err := rows.Scan(
                        &amp;participant.ParticipantID,
                        &amp;participant.Nickname,
                        &amp;participant.SelectedOption,
                        &amp;participant.AnsweredAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "SCAN_ERROR",
                                        Message: "Failed to scan participant data",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">correctParticipants = append(correctParticipants, participant)</span>
        }

        // Get total answer counts
        <span class="cov0" title="0">var totalCorrect, totalAnswers int
        countQuery := `SELECT 
                                        COUNT(CASE WHEN is_correct THEN 1 END) as correct_count,
                                        COUNT(*) as total_count
                                        FROM answers WHERE quiz_id = $1`

        err = db.QueryRow(countQuery, quizID).Scan(&amp;totalCorrect, &amp;totalAnswers)
        if err != nil </span><span class="cov0" title="0">{
                totalCorrect = len(correctParticipants)
                totalAnswers = totalCorrect
        }</span>

        <span class="cov0" title="0">correctPercentage := calculatePercentage(totalCorrect, totalAnswers)

        response := models.QuizRankingResponse{
                QuizID:              quizID,
                QuestionText:        questionText,
                CorrectParticipants: correctParticipants,
                TotalCorrect:        totalCorrect,
                TotalAnswers:        totalAnswers,
                CorrectPercentage:   correctPercentage,
        }

        c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Data:    response,
        })</span>
}

// GetParticipantRanking returns ranking information for a specific participant
func GetParticipantRanking(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        participantID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "INVALID_ID",
                                Message: "Invalid participant ID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">db := database.GetDB()

        // Check if participant exists and get basic info
        var nickname string
        err = db.QueryRow("SELECT nickname FROM participants WHERE id = $1", participantID).Scan(&amp;nickname)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "PARTICIPANT_NOT_FOUND",
                                        Message: "Participant not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to get participant",
                        },
                })
                return</span>
        }

        // Get participant stats
        <span class="cov0" title="0">var totalAnswers, correctAnswers int
        statsQuery := `SELECT COUNT(*), COALESCE(SUM(CASE WHEN is_correct THEN 1 ELSE 0 END), 0)
                                   FROM answers WHERE participant_id = $1`

        err = db.QueryRow(statsQuery, participantID).Scan(&amp;totalAnswers, &amp;correctAnswers)
        if err != nil </span><span class="cov0" title="0">{
                totalAnswers = 0
                correctAnswers = 0
        }</span>

        <span class="cov0" title="0">var accuracyRate float64
        if totalAnswers &gt; 0 </span><span class="cov0" title="0">{
                accuracyRate = float64(correctAnswers) / float64(totalAnswers)
        }</span>

        // Get participant's rank
        <span class="cov0" title="0">rankQuery := `SELECT COUNT(*) + 1 as rank
                                  FROM (
                                          SELECT p.id,
                                                     COALESCE(SUM(CASE WHEN a.is_correct THEN 1 ELSE 0 END), 0) as score,
                                                     CASE 
                                                            WHEN COUNT(a.id) &gt; 0 THEN 
                                                                    CAST(SUM(CASE WHEN a.is_correct THEN 1 ELSE 0 END) AS FLOAT) / COUNT(a.id)
                                                            ELSE 0 
                                                     END as acc_rate,
                                                     COUNT(a.id) as total_ans
                                          FROM participants p
                                          LEFT JOIN answers a ON p.id = a.participant_id
                                          GROUP BY p.id
                                  ) sub
                                  WHERE (sub.score &gt; $1) 
                                     OR (sub.score = $1 AND sub.acc_rate &gt; $2)
                                     OR (sub.score = $1 AND sub.acc_rate = $2 AND sub.total_ans &gt; $3)`

        var currentRank int
        err = db.QueryRow(rankQuery, correctAnswers, accuracyRate, totalAnswers).Scan(&amp;currentRank)
        if err != nil </span><span class="cov0" title="0">{
                currentRank = 1
        }</span>

        // Get total participants
        <span class="cov0" title="0">var totalParticipants int
        err = db.QueryRow("SELECT COUNT(*) FROM participants").Scan(&amp;totalParticipants)
        if err != nil </span><span class="cov0" title="0">{
                totalParticipants = 1
        }</span>

        // Calculate percentile
        <span class="cov0" title="0">percentile := float64(totalParticipants-currentRank+1) / float64(totalParticipants) * 100

        response := models.ParticipantRankingResponse{
                ParticipantID:     participantID,
                Nickname:          nickname,
                CurrentRank:       currentRank,
                TotalParticipants: totalParticipants,
                TotalAnswers:      totalAnswers,
                CorrectAnswers:    correctAnswers,
                AccuracyRate:      accuracyRate,
                TotalScore:        correctAnswers,
                Percentile:        percentile,
        }

        c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Data:    response,
        })</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "database/sql"
        "net/http"

        "github.com/Tattsum/quiz/internal/database"
        "github.com/Tattsum/quiz/internal/models"
        "github.com/gin-gonic/gin"
)

// GetSessionStatus returns current session status
func GetSessionStatus(c *gin.Context) <span class="cov0" title="0">{
        db := database.GetDB()

        // Get current session
        var session models.QuizSession
        sessionQuery := `SELECT id, current_quiz_id, is_accepting_answers, created_at, updated_at 
                                         FROM quiz_sessions 
                                         ORDER BY id DESC 
                                         LIMIT 1`

        err := db.QueryRow(sessionQuery).Scan(
                &amp;session.ID,
                &amp;session.CurrentQuizID,
                &amp;session.IsAcceptingAnswers,
                &amp;session.CreatedAt,
                &amp;session.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, models.APIResponse{
                                Success: true,
                                Data: models.SessionStatusResponse{
                                        SessionID:          0,
                                        CurrentQuiz:        nil,
                                        IsAcceptingAnswers: false,
                                        TotalParticipants:  0,
                                        AnswersCount:       0,
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to query session",
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">var response models.SessionStatusResponse
        response.SessionID = session.ID
        response.IsAcceptingAnswers = session.IsAcceptingAnswers

        // Get current quiz if available
        if session.CurrentQuizID != nil </span><span class="cov0" title="0">{
                var quiz models.Quiz
                quizQuery := `SELECT id, question_text, option_a, option_b, option_c, option_d, 
                                          image_url, video_url
                                          FROM quizzes WHERE id = $1`

                err = db.QueryRow(quizQuery, *session.CurrentQuizID).Scan(
                        &amp;quiz.ID,
                        &amp;quiz.QuestionText,
                        &amp;quiz.OptionA,
                        &amp;quiz.OptionB,
                        &amp;quiz.OptionC,
                        &amp;quiz.OptionD,
                        &amp;quiz.ImageURL,
                        &amp;quiz.VideoURL,
                )

                if err == nil </span><span class="cov0" title="0">{
                        currentQuiz := convertQuizToPublic(quiz)
                        response.CurrentQuiz = &amp;currentQuiz
                }</span>

                // Get answers count for current quiz
                <span class="cov0" title="0">var answersCount int
                err = db.QueryRow("SELECT COUNT(*) FROM answers WHERE quiz_id = $1", *session.CurrentQuizID).Scan(&amp;answersCount)
                if err == nil </span><span class="cov0" title="0">{
                        response.AnswersCount = answersCount
                }</span>
        }

        // Get total participants
        <span class="cov0" title="0">var totalParticipants int
        err = db.QueryRow("SELECT COUNT(*) FROM participants").Scan(&amp;totalParticipants)
        if err == nil </span><span class="cov0" title="0">{
                response.TotalParticipants = totalParticipants
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Data:    response,
        })</span>
}

// StartSession starts a new quiz session
func StartSession(c *gin.Context) <span class="cov0" title="0">{
        var req models.SessionStartRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: "Invalid request data",
                                Details: parseValidationErrors(err),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">db := database.GetDB()

        // Check if quiz exists
        var quiz models.Quiz
        quizQuery := `SELECT id, question_text, option_a, option_b, option_c, option_d, 
                                  image_url, video_url
                                  FROM quizzes WHERE id = $1`

        err := db.QueryRow(quizQuery, req.QuizID).Scan(
                &amp;quiz.ID,
                &amp;quiz.QuestionText,
                &amp;quiz.OptionA,
                &amp;quiz.OptionB,
                &amp;quiz.OptionC,
                &amp;quiz.OptionD,
                &amp;quiz.ImageURL,
                &amp;quiz.VideoURL,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "QUIZ_NOT_FOUND",
                                        Message: "Quiz not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to query quiz",
                        },
                })
                return</span>
        }

        // Create new session
        <span class="cov0" title="0">sessionQuery := `INSERT INTO quiz_sessions (current_quiz_id, is_accepting_answers, created_at, updated_at)
                                         VALUES ($1, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                                         RETURNING id, created_at, updated_at`

        var sessionID int64
        err = db.QueryRow(sessionQuery, req.QuizID).Scan(&amp;sessionID, &amp;quiz.CreatedAt, &amp;quiz.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to create session",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">currentQuiz := convertQuizToPublic(quiz)

        // Broadcast session start and first question
        BroadcastQuestionSwitch(quiz.ID, 1, 1)
        BroadcastSessionUpdate(map[string]interface{}{
                "session_id":           sessionID,
                "quiz":                 currentQuiz,
                "is_accepting_answers": true,
                "status":               "started",
        })

        c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Message: "クイズセッションが開始されました",
                Data: map[string]interface{}{
                        "session_id":           sessionID,
                        "quiz":                 currentQuiz,
                        "is_accepting_answers": true,
                },
        })</span>
}

// NextQuestion moves to the next question
func NextQuestion(c *gin.Context) <span class="cov0" title="0">{
        var req models.SessionNextRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: "Invalid request data",
                                Details: parseValidationErrors(err),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">db := database.GetDB()

        // Check if quiz exists
        var quiz models.Quiz
        quizQuery := `SELECT id, question_text, option_a, option_b, option_c, option_d, 
                                  image_url, video_url
                                  FROM quizzes WHERE id = $1`

        err := db.QueryRow(quizQuery, req.QuizID).Scan(
                &amp;quiz.ID,
                &amp;quiz.QuestionText,
                &amp;quiz.OptionA,
                &amp;quiz.OptionB,
                &amp;quiz.OptionC,
                &amp;quiz.OptionD,
                &amp;quiz.ImageURL,
                &amp;quiz.VideoURL,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, models.APIResponse{
                                Success: false,
                                Error: &amp;models.APIError{
                                        Code:    "QUIZ_NOT_FOUND",
                                        Message: "Quiz not found",
                                },
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to query quiz",
                        },
                })
                return</span>
        }

        // Get current session and update it
        <span class="cov0" title="0">sessionQuery := `UPDATE quiz_sessions 
                                         SET current_quiz_id = $1, is_accepting_answers = true, updated_at = CURRENT_TIMESTAMP
                                         WHERE id = (SELECT id FROM quiz_sessions ORDER BY id DESC LIMIT 1)
                                         RETURNING id`

        var sessionID int64
        err = db.QueryRow(sessionQuery, req.QuizID).Scan(&amp;sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to update session",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">currentQuiz := convertQuizToPublic(quiz)

        // Broadcast question switch (assuming question numbers for now)
        BroadcastQuestionSwitch(quiz.ID, 1, 1)
        BroadcastSessionUpdate(map[string]interface{}{
                "session_id":           sessionID,
                "quiz":                 currentQuiz,
                "is_accepting_answers": true,
                "status":               "question_changed",
        })

        c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Message: "次の問題に進みました",
                Data: map[string]interface{}{
                        "session_id":           sessionID,
                        "quiz":                 currentQuiz,
                        "is_accepting_answers": true,
                },
        })</span>
}

// ToggleAnswers toggles answer acceptance for current session
func ToggleAnswers(c *gin.Context) <span class="cov0" title="0">{
        var req models.ToggleAnswersRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "VALIDATION_ERROR",
                                Message: "Invalid request data",
                                Details: parseValidationErrors(err),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">db := database.GetDB()

        // Update current session
        sessionQuery := `UPDATE quiz_sessions 
                                         SET is_accepting_answers = $1, updated_at = CURRENT_TIMESTAMP
                                         WHERE id = (SELECT id FROM quiz_sessions ORDER BY id DESC LIMIT 1)`

        _, err := db.Exec(sessionQuery, req.IsAcceptingAnswers)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to update session",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">message := "回答受付を開始しました"
        if !req.IsAcceptingAnswers </span><span class="cov0" title="0">{
                message = "回答受付を停止しました"
                // Broadcast voting end when answers are stopped
                var currentQuizID *int64
                _ = db.QueryRow("SELECT current_quiz_id FROM quiz_sessions ORDER BY id DESC LIMIT 1").Scan(&amp;currentQuizID)
                if currentQuizID != nil </span><span class="cov0" title="0">{
                        BroadcastVotingEnd(*currentQuizID, *currentQuizID)
                }</span>
        }

        // Broadcast session update
        <span class="cov0" title="0">BroadcastSessionUpdate(map[string]interface{}{
                "is_accepting_answers": req.IsAcceptingAnswers,
                "status":               "answer_acceptance_toggled",
        })

        c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Message: message,
                Data: map[string]interface{}{
                        "is_accepting_answers": req.IsAcceptingAnswers,
                },
        })</span>
}

// EndSession ends the current quiz session
func EndSession(c *gin.Context) <span class="cov0" title="0">{
        db := database.GetDB()

        // Update current session to stop accepting answers
        sessionQuery := `UPDATE quiz_sessions 
                                         SET is_accepting_answers = false, current_quiz_id = NULL, updated_at = CURRENT_TIMESTAMP
                                         WHERE id = (SELECT id FROM quiz_sessions ORDER BY id DESC LIMIT 1)`

        _, err := db.Exec(sessionQuery)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "DATABASE_ERROR",
                                Message: "Failed to end session",
                        },
                })
                return
        }</span>

        // Broadcast session end
        <span class="cov0" title="0">BroadcastSessionUpdate(map[string]interface{}{
                "is_accepting_answers": false,
                "current_quiz":         nil,
                "status":               "ended",
        })

        c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Message: "クイズセッションが終了されました",
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import "os"

const testEnvValue = "true"

// setupTestEnv sets up test environment variables if not already set
func setupTestEnv() <span class="cov10" title="17">{
        if os.Getenv("TEST_ENV") == testEnvValue </span><span class="cov0" title="0">{
                return
        }</span>

        // Set default test database configuration
        <span class="cov10" title="17">if os.Getenv("DB_HOST") == "" </span><span class="cov1" title="1">{
                _ = os.Setenv("DB_HOST", "localhost")
        }</span>
        <span class="cov10" title="17">if os.Getenv("DB_PORT") == "" </span><span class="cov1" title="1">{
                _ = os.Setenv("DB_PORT", "5433")
        }</span>
        <span class="cov10" title="17">if os.Getenv("DB_USER") == "" </span><span class="cov1" title="1">{
                _ = os.Setenv("DB_USER", "quiz_user")
        }</span>
        <span class="cov10" title="17">if os.Getenv("DB_PASSWORD") == "" </span><span class="cov1" title="1">{
                _ = os.Setenv("DB_PASSWORD", "quiz_password")
        }</span>
        <span class="cov10" title="17">if os.Getenv("DB_NAME") == "" </span><span class="cov1" title="1">{
                _ = os.Setenv("DB_NAME", "quiz_db_test")
        }</span>
        <span class="cov10" title="17">if os.Getenv("DB_SSLMODE") == "" </span><span class="cov1" title="1">{
                _ = os.Setenv("DB_SSLMODE", "disable")
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "fmt"
        "net/http"

        "github.com/Tattsum/quiz/internal/models"
        "github.com/Tattsum/quiz/internal/services"
        "github.com/gin-gonic/gin"
)

// ImageUploadHandler handles image upload requests
type ImageUploadHandler struct {
        imageService   *services.ImageService
        storageService services.StorageService
}

// NewImageUploadHandler creates a new ImageUploadHandler instance
func NewImageUploadHandler(storageService services.StorageService) *ImageUploadHandler <span class="cov0" title="0">{
        return &amp;ImageUploadHandler{
                imageService:   services.NewImageService(),
                storageService: storageService,
        }
}</span>

// UploadImage handles image file upload with validation, processing, and storage
func (h *ImageUploadHandler) UploadImage(c *gin.Context) <span class="cov0" title="0">{
        file, err := c.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "NO_FILE",
                                Message: "No file uploaded",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">imageUpload, processedData, err := h.imageService.ProcessImage(file)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "PROCESSING_ERROR",
                                Message: err.Error(),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">if err := h.storageService.Store(imageUpload, processedData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.APIResponse{
                        Success: false,
                        Error: &amp;models.APIError{
                                Code:    "STORAGE_ERROR",
                                Message: "Failed to store uploaded image",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">response := models.UploadResponse{
                URL:      imageUpload.URL,
                Filename: imageUpload.Filename,
                Size:     imageUpload.Size,
        }

        c.JSON(http.StatusOK, models.APIResponse{
                Success: true,
                Message: "画像がアップロードされました",
                Data:    response,
        })</span>
}

// UploadImage is the legacy function that maintains compatibility
func UploadImage(c *gin.Context) <span class="cov0" title="0">{
        uploadDir := "uploads/images"
        baseURL := getBaseURL(c)

        storageService := services.NewLocalStorageService(uploadDir, baseURL)
        handler := NewImageUploadHandler(storageService)
        handler.UploadImage(c)
}</span>

// getBaseURL returns the base URL for the application
func getBaseURL(c *gin.Context) string <span class="cov0" title="0">{
        scheme := "http"
        if c.Request.TLS != nil </span><span class="cov0" title="0">{
                scheme = "https"
        }</span>

        // Check for forwarded protocol header (for reverse proxies)
        <span class="cov0" title="0">if proto := c.GetHeader("X-Forwarded-Proto"); proto != "" </span><span class="cov0" title="0">{
                scheme = proto
        }</span>

        <span class="cov0" title="0">host := c.Request.Host
        if host == "" </span><span class="cov0" title="0">{
                host = "localhost:8080"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s://%s", scheme, host)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "encoding/json"
        "log"
        "net/http"
        "sync"
        "time"

        "github.com/Tattsum/quiz/internal/database"
        "github.com/Tattsum/quiz/internal/models"
        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
)

const (
        // MaxConnections is the maximum number of concurrent WebSocket connections allowed
        MaxConnections = 70 // 最大接続数
)

var (
        upgrader = websocket.Upgrader{
                CheckOrigin: func(_ /*r*/ *http.Request) bool <span class="cov8" title="20">{
                        // In production, implement proper origin checking
                        return true
                }</span>,
        }

        // Store active WebSocket connections
        connections      = make(map[*websocket.Conn]*ClientConnection)
        connectionsMutex = sync.RWMutex{}
)

// ClientConnection represents a WebSocket client connection
type ClientConnection struct {
        Conn          *websocket.Conn
        QuizID        *int64
        LastHeartbeat time.Time
}

// WebSocketMessage represents a WebSocket message
type WebSocketMessage struct {
        Type string      `json:"type"`
        Data interface{} `json:"data"`
}

// SubscribeMessage represents a subscription message
type SubscribeMessage struct {
        Type   string `json:"type"`
        QuizID int64  `json:"quiz_id"`
}

// QuestionSwitchNotification represents a question switch notification
type QuestionSwitchNotification struct {
        QuizID         int64     `json:"quiz_id"`
        QuestionNumber int       `json:"question_number"`
        TotalQuestions int       `json:"total_questions"`
        SwitchedAt     time.Time `json:"switched_at"`
}

// VotingEndNotification represents a voting end notification
type VotingEndNotification struct {
        QuizID     int64     `json:"quiz_id"`
        QuestionID int64     `json:"question_id"`
        EndedAt    time.Time `json:"ended_at"`
}

// AnswerStatusUpdate represents current answer status
type AnswerStatusUpdate struct {
        QuizID            int64          `json:"quiz_id"`
        QuestionID        int64          `json:"question_id"`
        TotalParticipants int            `json:"total_participants"`
        AnsweredCount     int            `json:"answered_count"`
        AnswerCounts      map[string]int `json:"answer_counts"`
        UpdatedAt         time.Time      `json:"updated_at"`
}

// WebSocketResults handles WebSocket connections for real-time results
//
//nolint:gocyclo
func WebSocketResults(c *gin.Context) <span class="cov8" title="20">{
        // Check connection limit
        connectionsMutex.RLock()
        currentConnections := len(connections)
        connectionsMutex.RUnlock()

        if currentConnections &gt;= MaxConnections </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{
                        "error":           "Maximum connections reached",
                        "max_connections": MaxConnections,
                })
                return
        }</span>

        <span class="cov8" title="20">conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WebSocket upgrade failed: %v", err)
                return
        }</span>
        <span class="cov8" title="20">defer func() </span><span class="cov8" title="20">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to close WebSocket connection: %v", err)
                }</span>
        }()

        // Register connection
        <span class="cov8" title="20">client := &amp;ClientConnection{
                Conn:          conn,
                LastHeartbeat: time.Now(),
        }

        connectionsMutex.Lock()
        connections[conn] = client
        log.Printf("New WebSocket connection established. Total connections: %d/%d", len(connections), MaxConnections)
        connectionsMutex.Unlock()

        // Remove connection when done
        defer func() </span><span class="cov8" title="20">{
                connectionsMutex.Lock()
                delete(connections, conn)
                log.Printf("WebSocket connection closed. Total connections: %d/%d", len(connections), MaxConnections)
                connectionsMutex.Unlock()
        }</span>()

        // Set up ping/pong for connection health check
        <span class="cov8" title="20">conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                client.LastHeartbeat = time.Now()
                return nil
        }</span>)

        // Start heartbeat goroutine
        <span class="cov8" title="20">go func() </span><span class="cov8" title="20">{
                ticker := time.NewTicker(30 * time.Second)
                defer ticker.Stop()

                //nolint:gosimple
                for </span><span class="cov8" title="20">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if err := conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }()

        // Handle incoming messages
        <span class="cov8" title="20">for </span><span class="cov10" title="36">{
                messageType, data, err := conn.ReadMessage()
                if err != nil </span><span class="cov8" title="20">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WebSocket error: %v", err)
                        }</span>
                        <span class="cov8" title="20">break</span>
                }

                <span class="cov7" title="16">if messageType == websocket.TextMessage </span><span class="cov7" title="16">{
                        var msg SubscribeMessage
                        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov1" title="1">{
                                log.Printf("Failed to unmarshal message: %v", err)
                                continue</span>
                        }

                        <span class="cov7" title="15">switch msg.Type </span>{
                        case "subscribe":<span class="cov7" title="12">
                                client.QuizID = &amp;msg.QuizID

                                // Send current results immediately
                                results, err := getCurrentQuizResults(msg.QuizID)
                                if err == nil </span><span class="cov5" title="6">{
                                        sendMessage(conn, "result_update", results)
                                }</span>

                        case "unsubscribe":<span class="cov1" title="1">
                                client.QuizID = nil</span>

                        case "heartbeat":<span class="cov2" title="2">
                                client.LastHeartbeat = time.Now()
                                sendMessage(conn, "heartbeat_ack", map[string]interface{}{
                                        "timestamp": time.Now(),
                                })</span>
                        }
                }
        }
}

// BroadcastResultUpdate broadcasts result updates to all subscribed clients
func BroadcastResultUpdate(quizID int64) <span class="cov1" title="1">{
        results, err := getCurrentQuizResults(quizID)
        if err != nil </span><span class="cov1" title="1">{
                log.Printf("Failed to get quiz results for broadcast: %v", err)
                return
        }</span>

        <span class="cov0" title="0">connectionsMutex.RLock()
        defer connectionsMutex.RUnlock()

        for conn, client := range connections </span><span class="cov0" title="0">{
                if client.QuizID != nil &amp;&amp; *client.QuizID == quizID </span><span class="cov0" title="0">{
                        go func(c *websocket.Conn) </span><span class="cov0" title="0">{
                                sendMessage(c, "result_update", results)
                        }</span>(conn)
                }
        }
}

// BroadcastSessionUpdate broadcasts session status updates to all clients
func BroadcastSessionUpdate(sessionData interface{}) <span class="cov1" title="1">{
        connectionsMutex.RLock()
        defer connectionsMutex.RUnlock()

        for conn := range connections </span><span class="cov0" title="0">{
                go func(c *websocket.Conn) </span><span class="cov0" title="0">{
                        sendMessage(c, "session_update", sessionData)
                }</span>(conn)
        }
}

// BroadcastQuestionSwitch broadcasts question switch notifications
func BroadcastQuestionSwitch(quizID int64, questionNumber, totalQuestions int) <span class="cov1" title="1">{
        notification := QuestionSwitchNotification{
                QuizID:         quizID,
                QuestionNumber: questionNumber,
                TotalQuestions: totalQuestions,
                SwitchedAt:     time.Now(),
        }

        connectionsMutex.RLock()
        defer connectionsMutex.RUnlock()

        for conn, client := range connections </span><span class="cov0" title="0">{
                if client.QuizID != nil &amp;&amp; *client.QuizID == quizID </span><span class="cov0" title="0">{
                        go func(c *websocket.Conn) </span><span class="cov0" title="0">{
                                sendMessage(c, "question_switch", notification)
                        }</span>(conn)
                }
        }

        <span class="cov1" title="1">log.Printf("Broadcasted question switch for quiz %d to %d subscribers", quizID, GetSubscriptionCount(quizID))</span>
}

// BroadcastVotingEnd broadcasts voting end notifications
func BroadcastVotingEnd(quizID, questionID int64) <span class="cov1" title="1">{
        notification := VotingEndNotification{
                QuizID:     quizID,
                QuestionID: questionID,
                EndedAt:    time.Now(),
        }

        connectionsMutex.RLock()
        defer connectionsMutex.RUnlock()

        for conn, client := range connections </span><span class="cov0" title="0">{
                if client.QuizID != nil &amp;&amp; *client.QuizID == quizID </span><span class="cov0" title="0">{
                        go func(c *websocket.Conn) </span><span class="cov0" title="0">{
                                sendMessage(c, "voting_end", notification)
                        }</span>(conn)
                }
        }

        <span class="cov1" title="1">log.Printf("Broadcasted voting end for quiz %d, question %d to %d subscribers", quizID, questionID, GetSubscriptionCount(quizID))</span>
}

// BroadcastAnswerStatus broadcasts current answer status
func BroadcastAnswerStatus(quizID, questionID int64, totalParticipants, answeredCount int, answerCounts map[string]int) <span class="cov2" title="2">{
        status := AnswerStatusUpdate{
                QuizID:            quizID,
                QuestionID:        questionID,
                TotalParticipants: totalParticipants,
                AnsweredCount:     answeredCount,
                AnswerCounts:      answerCounts,
                UpdatedAt:         time.Now(),
        }

        connectionsMutex.RLock()
        defer connectionsMutex.RUnlock()

        for conn, client := range connections </span><span class="cov0" title="0">{
                if client.QuizID != nil &amp;&amp; *client.QuizID == quizID </span><span class="cov0" title="0">{
                        go func(c *websocket.Conn) </span><span class="cov0" title="0">{
                                sendMessage(c, "answer_status", status)
                        }</span>(conn)
                }
        }
}

// sendMessage sends a message to a WebSocket connection
func sendMessage(conn *websocket.Conn, messageType string, data interface{}) <span class="cov6" title="8">{
        message := WebSocketMessage{
                Type: messageType,
                Data: data,
        }

        if err := conn.WriteJSON(message); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send WebSocket message: %v", err)
        }</span>
}

// getCurrentQuizResults gets current results for a quiz
func getCurrentQuizResults(quizID int64) (*models.QuizResultsResponse, error) <span class="cov7" title="13">{
        db := database.GetDB()
        return getQuizResultsData(db, quizID, nil)
}</span>

// CleanupConnections removes stale WebSocket connections
func CleanupConnections() <span class="cov1" title="1">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        //nolint:gosimple
        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        connectionsMutex.Lock()
                        cutoff := time.Now().Add(-2 * time.Minute)

                        for conn, client := range connections </span><span class="cov0" title="0">{
                                if client.LastHeartbeat.Before(cutoff) </span><span class="cov0" title="0">{
                                        _ = conn.Close()
                                        delete(connections, conn)
                                }</span>
                        }
                        <span class="cov0" title="0">connectionsMutex.Unlock()</span>
                }
        }
}

// GetConnectionCount returns the current number of active WebSocket connections
func GetConnectionCount() int <span class="cov1" title="1">{
        connectionsMutex.RLock()
        defer connectionsMutex.RUnlock()
        return len(connections)
}</span>

// GetSubscriptionCount returns the number of connections subscribed to a specific quiz
func GetSubscriptionCount(quizID int64) int <span class="cov3" title="3">{
        connectionsMutex.RLock()
        defer connectionsMutex.RUnlock()

        count := 0
        for _, client := range connections </span><span class="cov0" title="0">{
                if client.QuizID != nil &amp;&amp; *client.QuizID == quizID </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov3" title="3">return count</span>
}

// init initializes the WebSocket cleanup goroutine
func init() <span class="cov1" title="1">{
        go CleanupConnections()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package services provides business logic and service layer functionality.
package services

import (
        "database/sql"
        "errors"
        "fmt"

        "golang.org/x/crypto/bcrypt"

        "github.com/Tattsum/quiz/internal/database"
        "github.com/Tattsum/quiz/internal/models"
)

// AuthService provides authentication related business logic
type AuthService struct {
        db *sql.DB
}

// NewAuthService creates a new AuthService instance
func NewAuthService() *AuthService <span class="cov1" title="1">{
        return &amp;AuthService{
                db: database.GetDB(),
        }
}</span>

// AuthenticateAdmin authenticates an admin user and returns admin details
func (s *AuthService) AuthenticateAdmin(username, password string) (*models.Administrator, error) <span class="cov10" title="4">{
        if username == "" || password == "" </span><span class="cov8" title="3">{
                return nil, errors.New("username and password are required")
        }</span>

        <span class="cov1" title="1">if s.db == nil </span><span class="cov1" title="1">{
                return nil, errors.New("database connection not initialized")
        }</span>

        <span class="cov0" title="0">admin, err := s.getAdminByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(admin.PasswordHash), []byte(password)); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid credentials")
        }</span>

        // Clear password hash for security
        <span class="cov0" title="0">admin.PasswordHash = ""
        return admin, nil</span>
}

// GetAdminByID retrieves an administrator by their ID
func (s *AuthService) GetAdminByID(id int64) (*models.Administrator, error) <span class="cov8" title="3">{
        if id &lt;= 0 </span><span class="cov5" title="2">{
                return nil, errors.New("invalid admin ID")
        }</span>

        <span class="cov1" title="1">if s.db == nil </span><span class="cov1" title="1">{
                return nil, errors.New("database connection not initialized")
        }</span>

        <span class="cov0" title="0">var admin models.Administrator
        query := `SELECT id, username, email, created_at, updated_at 
                          FROM administrators WHERE id = $1`

        err := s.db.QueryRow(query, id).Scan(
                &amp;admin.ID,
                &amp;admin.Username,
                &amp;admin.Email,
                &amp;admin.CreatedAt,
                &amp;admin.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, errors.New("admin not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get admin: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;admin, nil</span>
}

func (s *AuthService) getAdminByUsername(username string) (*models.Administrator, error) <span class="cov0" title="0">{
        if s.db == nil </span><span class="cov0" title="0">{
                return nil, errors.New("database connection not initialized")
        }</span>

        <span class="cov0" title="0">var admin models.Administrator
        query := `SELECT id, username, password_hash, email, created_at, updated_at 
                          FROM administrators WHERE username = $1`

        err := s.db.QueryRow(query, username).Scan(
                &amp;admin.ID,
                &amp;admin.Username,
                &amp;admin.PasswordHash,
                &amp;admin.Email,
                &amp;admin.CreatedAt,
                &amp;admin.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid credentials")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get admin: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;admin, nil</span>
}

// HashPassword generates a bcrypt hash of the password
func (s *AuthService) HashPassword(password string) (string, error) <span class="cov5" title="2">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes), err
}</span>

// CreateAdmin creates a new administrator (for initial setup or testing)
func (s *AuthService) CreateAdmin(username, password, email string) (*models.Administrator, error) <span class="cov0" title="0">{
        if username == "" || password == "" || email == "" </span><span class="cov0" title="0">{
                return nil, errors.New("username, password, and email are required")
        }</span>

        <span class="cov0" title="0">hashedPassword, err := s.HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        <span class="cov0" title="0">query := `INSERT INTO administrators (username, password_hash, email, created_at, updated_at) 
                          VALUES ($1, $2, $3, NOW(), NOW()) 
                          RETURNING id, username, email, created_at, updated_at`

        var admin models.Administrator
        err = s.db.QueryRow(query, username, hashedPassword, email).Scan(
                &amp;admin.ID,
                &amp;admin.Username,
                &amp;admin.Email,
                &amp;admin.CreatedAt,
                &amp;admin.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create admin: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;admin, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package services

import (
        "bytes"
        "fmt"
        "image"
        "image/gif"
        "image/jpeg"
        "image/png"
        "mime/multipart"
        "path/filepath"
        "strings"
        "time"

        "github.com/Tattsum/quiz/internal/models"
        "github.com/disintegration/imaging"
        "github.com/google/uuid"
)

const (
        // MaxFileSize defines the maximum allowed file size for image uploads (5MB)
        MaxFileSize    = 5 * 1024 * 1024
        MaxImageWidth  = 1920
        MaxImageHeight = 1080
        JpegQuality    = 80

        // FormatJPEG represents the JPEG image format
        FormatJPEG = "jpeg"
        // FormatPNG represents the PNG image format
        FormatPNG = "png"
        // FormatGIF represents the GIF image format
        FormatGIF = "gif"

        // ContentTypeJPEG represents the MIME type for JPEG images
        ContentTypeJPEG = "image/jpeg"
        // ContentTypePNG represents the MIME type for PNG images
        ContentTypePNG = "image/png"
        // ContentTypeGIF represents the MIME type for GIF images
        ContentTypeGIF = "image/gif"
)

// AllowedContentTypes defines the supported image content types
var AllowedContentTypes = map[string]bool{
        ContentTypeJPEG: true,
        ContentTypePNG:  true,
        ContentTypeGIF:  true,
}

// ImageService provides image processing and validation functionality
type ImageService struct{}

// NewImageService creates a new ImageService instance
func NewImageService() *ImageService <span class="cov4" title="6">{
        return &amp;ImageService{}
}</span>

// ImageValidationResult contains the result of image validation
type ImageValidationResult struct {
        IsValid     bool
        ContentType string
        Size        int64
        Width       int
        Height      int
        Error       error
}

// ValidateImage validates an uploaded image file
func (s *ImageService) ValidateImage(fileHeader *multipart.FileHeader) (*ImageValidationResult, error) <span class="cov3" title="5">{
        result := &amp;ImageValidationResult{}

        if fileHeader.Size &gt; MaxFileSize </span><span class="cov1" title="1">{
                result.Error = fmt.Errorf("file size %d exceeds maximum allowed size %d", fileHeader.Size, MaxFileSize)
                return result, nil
        }</span>

        <span class="cov3" title="4">file, err := fileHeader.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open uploaded file: %w", err)
        }</span>
        <span class="cov3" title="4">defer func() </span><span class="cov3" title="4">{ _ = file.Close() }</span>()

        <span class="cov3" title="4">buffer := make([]byte, 512)
        _, err = file.Read(buffer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file header: %w", err)
        }</span>

        <span class="cov3" title="4">contentType := s.detectContentType(buffer)
        if !AllowedContentTypes[contentType] </span><span class="cov1" title="1">{
                result.Error = fmt.Errorf("unsupported file type: %s. Allowed types: jpeg, png, gif", contentType)
                return result, nil
        }</span>

        <span class="cov2" title="3">if _, err := file.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to reset file pointer: %w", err)
        }</span>

        <span class="cov2" title="3">img, format, err := image.DecodeConfig(file)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("invalid image file: %w", err)
                return result, nil
        }</span>

        <span class="cov2" title="3">expectedFormat := s.getExpectedFormat(contentType)
        if format != expectedFormat </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("content type mismatch: expected %s but got %s", expectedFormat, format)
                return result, nil
        }</span>

        <span class="cov2" title="3">result.IsValid = true
        result.ContentType = contentType
        result.Size = fileHeader.Size
        result.Width = img.Width
        result.Height = img.Height

        return result, nil</span>
}

// ProcessImage processes and resizes an uploaded image
func (s *ImageService) ProcessImage(fileHeader *multipart.FileHeader) (*models.ImageUpload, []byte, error) <span class="cov2" title="2">{
        validation, err := s.ValidateImage(fileHeader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov2" title="2">if !validation.IsValid </span><span class="cov0" title="0">{
                return nil, nil, validation.Error
        }</span>

        <span class="cov2" title="2">file, err := fileHeader.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{ _ = file.Close() }</span>()

        <span class="cov2" title="2">originalImg, format, err := image.Decode(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to decode image: %w", err)
        }</span>

        <span class="cov2" title="2">processedImg := originalImg
        newWidth := validation.Width
        newHeight := validation.Height

        if validation.Width &gt; MaxImageWidth </span><span class="cov1" title="1">{
                ratio := float64(MaxImageWidth) / float64(validation.Width)
                newWidth = MaxImageWidth
                newHeight = int(float64(validation.Height) * ratio)
                processedImg = imaging.Resize(originalImg, newWidth, newHeight, imaging.Lanczos)
        }</span>

        <span class="cov2" title="2">var buf bytes.Buffer
        switch format </span>{
        case FormatJPEG:<span class="cov2" title="2">
                err = jpeg.Encode(&amp;buf, processedImg, &amp;jpeg.Options{Quality: JpegQuality})</span>
        case FormatPNG:<span class="cov0" title="0">
                err = png.Encode(&amp;buf, processedImg)</span>
        case FormatGIF:<span class="cov0" title="0">
                err = gif.Encode(&amp;buf, processedImg, nil)</span>
        }

        <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to encode processed image: %w", err)
        }</span>

        <span class="cov2" title="2">filename := s.generateFilename(fileHeader.Filename, format)

        imageUpload := &amp;models.ImageUpload{
                OriginalName: fileHeader.Filename,
                Filename:     filename,
                ContentType:  validation.ContentType,
                Size:         int64(buf.Len()),
                Width:        newWidth,
                Height:       newHeight,
                CreatedAt:    time.Now(),
        }

        return imageUpload, buf.Bytes(), nil</span>
}

func (s *ImageService) detectContentType(buffer []byte) string <span class="cov5" title="12">{
        if len(buffer) &lt; 12 </span><span class="cov2" title="2">{
                return ""
        }</span>

        <span class="cov4" title="10">if bytes.HasPrefix(buffer, []byte{0xFF, 0xD8, 0xFF}) </span><span class="cov3" title="5">{
                return ContentTypeJPEG
        }</span>

        <span class="cov3" title="5">if bytes.HasPrefix(buffer, []byte{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A}) </span><span class="cov2" title="2">{
                return ContentTypePNG
        }</span>

        <span class="cov2" title="3">if bytes.HasPrefix(buffer, []byte("GIF87a")) || bytes.HasPrefix(buffer, []byte("GIF89a")) </span><span class="cov2" title="2">{
                return ContentTypeGIF
        }</span>

        <span class="cov1" title="1">return ""</span>
}

func (s *ImageService) getExpectedFormat(contentType string) string <span class="cov2" title="3">{
        switch contentType </span>{
        case ContentTypeJPEG:<span class="cov2" title="3">
                return FormatJPEG</span>
        case ContentTypePNG:<span class="cov0" title="0">
                return FormatPNG</span>
        case ContentTypeGIF:<span class="cov0" title="0">
                return FormatGIF</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func (s *ImageService) generateFilename(originalName, format string) string <span class="cov2" title="2">{
        ext := s.getFileExtension(format)
        name := strings.TrimSuffix(originalName, filepath.Ext(originalName))

        cleanName := s.sanitizeFilename(name)
        if len(cleanName) &gt; 50 </span><span class="cov0" title="0">{
                cleanName = cleanName[:50]
        }</span>

        <span class="cov2" title="2">timestamp := time.Now().Format("20060102_150405")
        uuid := uuid.New().String()[:8]

        return fmt.Sprintf("%s_%s_%s%s", cleanName, timestamp, uuid, ext)</span>
}

func (s *ImageService) getFileExtension(format string) string <span class="cov2" title="2">{
        switch format </span>{
        case "jpeg":<span class="cov2" title="2">
                return ".jpg"</span>
        case "png":<span class="cov0" title="0">
                return ".png"</span>
        case "gif":<span class="cov0" title="0">
                return ".gif"</span>
        default:<span class="cov0" title="0">
                return ".jpg"</span>
        }
}

func (s *ImageService) sanitizeFilename(name string) string <span class="cov5" title="11">{
        name = strings.ReplaceAll(name, " ", "_")

        var result strings.Builder
        for _, r := range name </span><span class="cov10" title="179">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '_' || r == '-' </span><span class="cov9" title="161">{
                        result.WriteRune(r)
                }</span>
        }

        <span class="cov5" title="11">sanitized := result.String()
        if sanitized == "" </span><span class="cov2" title="2">{
                sanitized = "image"
        }</span>

        <span class="cov5" title="11">return sanitized</span>
}

// GetImageInfo extracts image information from binary data
func (s *ImageService) GetImageInfo(data []byte) (*ImageValidationResult, error) <span class="cov0" title="0">{
        reader := bytes.NewReader(data)

        config, format, err := image.DecodeConfig(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode image config: %w", err)
        }</span>

        <span class="cov0" title="0">contentType := ""
        switch format </span>{
        case "jpeg":<span class="cov0" title="0">
                contentType = "image/jpeg"</span>
        case "png":<span class="cov0" title="0">
                contentType = "image/png"</span>
        case "gif":<span class="cov0" title="0">
                contentType = "image/gif"</span>
        }

        <span class="cov0" title="0">return &amp;ImageValidationResult{
                IsValid:     true,
                ContentType: contentType,
                Size:        int64(len(data)),
                Width:       config.Width,
                Height:      config.Height,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package services

import (
        "crypto/rand"
        "encoding/hex"
        "errors"
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/Tattsum/quiz/internal/models"
        "github.com/golang-jwt/jwt/v5"
)

var (
        // ErrInvalidToken is returned when a JWT token is invalid
        ErrInvalidToken = errors.New("invalid token")
        // ErrExpiredToken is returned when a JWT token has expired
        ErrExpiredToken = errors.New("token has expired")
        // ErrInvalidTokenType is returned when a JWT token has an invalid type
        ErrInvalidTokenType = errors.New("invalid token type")
)

// JWTService provides JWT token generation and validation functionality
type JWTService struct {
        accessSecretKey   string
        refreshSecretKey  string
        accessExpiryTime  time.Duration
        refreshExpiryTime time.Duration
}

// NewJWTService creates a new JWT service instance with configuration from environment variables
func NewJWTService() *JWTService <span class="cov8" title="6">{
        accessSecret := os.Getenv("JWT_ACCESS_SECRET")
        if accessSecret == "" </span><span class="cov0" title="0">{
                accessSecret = "default_access_secret_key_change_in_production"
        }</span>

        <span class="cov8" title="6">refreshSecret := os.Getenv("JWT_REFRESH_SECRET")
        if refreshSecret == "" </span><span class="cov0" title="0">{
                refreshSecret = "default_refresh_secret_key_change_in_production"
        }</span>

        <span class="cov8" title="6">accessExpiryStr := os.Getenv("JWT_ACCESS_EXPIRY")
        accessExpiry := 15 * time.Minute
        if accessExpiryStr != "" </span><span class="cov8" title="6">{
                if minutes, err := strconv.Atoi(accessExpiryStr); err == nil </span><span class="cov8" title="6">{
                        accessExpiry = time.Duration(minutes) * time.Minute
                }</span>
        }

        <span class="cov8" title="6">refreshExpiryStr := os.Getenv("JWT_REFRESH_EXPIRY")
        refreshExpiry := 7 * 24 * time.Hour
        if refreshExpiryStr != "" </span><span class="cov8" title="6">{
                if hours, err := strconv.Atoi(refreshExpiryStr); err == nil </span><span class="cov8" title="6">{
                        refreshExpiry = time.Duration(hours) * time.Hour
                }</span>
        }

        <span class="cov8" title="6">return &amp;JWTService{
                accessSecretKey:   accessSecret,
                refreshSecretKey:  refreshSecret,
                accessExpiryTime:  accessExpiry,
                refreshExpiryTime: refreshExpiry,
        }</span>
}

// GenerateTokenPair generates access and refresh token pair for an administrator
func (j *JWTService) GenerateTokenPair(admin *models.Administrator) (*models.LoginResponse, error) <span class="cov7" title="5">{
        now := time.Now()
        accessExpiresAt := now.Add(j.accessExpiryTime)
        refreshExpiresAt := now.Add(j.refreshExpiryTime)

        accessClaims := &amp;models.JWTClaims{
                AdminID:  admin.ID,
                Username: admin.Username,
                Type:     "access",
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(accessExpiresAt),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    "quiz-app",
                        Subject:   fmt.Sprintf("admin:%d", admin.ID),
                },
        }

        refreshClaims := &amp;models.JWTClaims{
                AdminID:  admin.ID,
                Username: admin.Username,
                Type:     "refresh",
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(refreshExpiresAt),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    "quiz-app",
                        Subject:   fmt.Sprintf("admin:%d", admin.ID),
                },
        }

        accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
        accessTokenString, err := accessToken.SignedString([]byte(j.accessSecretKey))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign access token: %w", err)
        }</span>

        <span class="cov7" title="5">refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
        refreshTokenString, err := refreshToken.SignedString([]byte(j.refreshSecretKey))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign refresh token: %w", err)
        }</span>

        <span class="cov7" title="5">adminCopy := *admin
        adminCopy.PasswordHash = ""

        return &amp;models.LoginResponse{
                AccessToken:  accessTokenString,
                RefreshToken: refreshTokenString,
                ExpiresAt:    accessExpiresAt,
                Admin:        adminCopy,
        }, nil</span>
}

// ValidateAccessToken validates an access token and returns its claims
func (j *JWTService) ValidateAccessToken(tokenString string) (*models.JWTClaims, error) <span class="cov7" title="4">{
        return j.validateToken(tokenString, j.accessSecretKey, "access")
}</span>

// ValidateRefreshToken validates a refresh token and returns its claims
func (j *JWTService) ValidateRefreshToken(tokenString string) (*models.JWTClaims, error) <span class="cov7" title="4">{
        return j.validateToken(tokenString, j.refreshSecretKey, "refresh")
}</span>

func (j *JWTService) validateToken(tokenString, secretKey, expectedType string) (*models.JWTClaims, error) <span class="cov10" title="8">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;models.JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov9" title="7">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov9" title="7">return []byte(secretKey), nil</span>
        })
        <span class="cov10" title="8">if err != nil </span><span class="cov5" title="3">{
                if errors.Is(err, jwt.ErrTokenExpired) </span><span class="cov0" title="0">{
                        return nil, ErrExpiredToken
                }</span>
                <span class="cov5" title="3">return nil, ErrInvalidToken</span>
        }

        <span class="cov7" title="5">claims, ok := token.Claims.(*models.JWTClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov7" title="5">if claims.Type != expectedType </span><span class="cov0" title="0">{
                return nil, ErrInvalidTokenType
        }</span>

        <span class="cov7" title="5">return claims, nil</span>
}

// RefreshTokens generates new token pair using a valid refresh token
func (j *JWTService) RefreshTokens(refreshTokenString string, admin *models.Administrator) (*models.RefreshTokenResponse, error) <span class="cov1" title="1">{
        claims, err := j.ValidateRefreshToken(refreshTokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if claims.AdminID != admin.ID </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov1" title="1">response, err := j.GenerateTokenPair(admin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;models.RefreshTokenResponse{
                AccessToken:  response.AccessToken,
                RefreshToken: response.RefreshToken,
                ExpiresAt:    response.ExpiresAt,
        }, nil</span>
}

// GenerateSecureRandomString generates a cryptographically secure random string
func (j *JWTService) GenerateSecureRandomString(length int) (string, error) <span class="cov8" title="6">{
        bytes := make([]byte, length)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="6">return hex.EncodeToString(bytes), nil</span>
}

// ExtractTokenFromHeader extracts JWT token from Authorization header
func (j *JWTService) ExtractTokenFromHeader(authHeader string) string <span class="cov7" title="5">{
        if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov1" title="1">{
                return authHeader[7:]
        }</span>
        <span class="cov7" title="4">return ""</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package services

import (
        "database/sql"
        "errors"
        "fmt"

        "github.com/Tattsum/quiz/internal/database"
        "github.com/Tattsum/quiz/internal/models"
)

// QuizService provides quiz related business logic
type QuizService struct {
        db *sql.DB
}

// NewQuizService creates a new QuizService instance
func NewQuizService() *QuizService <span class="cov5" title="2">{
        return &amp;QuizService{
                db: database.GetDB(),
        }
}</span>

// CreateQuiz creates a new quiz in the database
func (s *QuizService) CreateQuiz(req models.QuizRequest) (*models.Quiz, error) <span class="cov0" title="0">{
        if err := s.validateQuizRequest(req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">query := `INSERT INTO quizzes (question_text, option_a, option_b, option_c, option_d, 
                          correct_answer, image_url, video_url, created_at, updated_at)
                          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                          RETURNING id, created_at, updated_at`

        var quiz models.Quiz
        err := s.db.QueryRow(query,
                req.QuestionText,
                req.OptionA,
                req.OptionB,
                req.OptionC,
                req.OptionD,
                req.CorrectAnswer,
                req.ImageURL,
                req.VideoURL,
        ).Scan(&amp;quiz.ID, &amp;quiz.CreatedAt, &amp;quiz.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create quiz: %w", err)
        }</span>

        <span class="cov0" title="0">quiz.QuestionText = req.QuestionText
        quiz.OptionA = req.OptionA
        quiz.OptionB = req.OptionB
        quiz.OptionC = req.OptionC
        quiz.OptionD = req.OptionD
        quiz.CorrectAnswer = req.CorrectAnswer
        quiz.ImageURL = req.ImageURL
        quiz.VideoURL = req.VideoURL

        return &amp;quiz, nil</span>
}

// GetQuizByID retrieves a quiz by its ID
func (s *QuizService) GetQuizByID(id int64) (*models.Quiz, error) <span class="cov8" title="3">{
        if id &lt;= 0 </span><span class="cov5" title="2">{
                return nil, errors.New("invalid quiz ID")
        }</span>

        <span class="cov1" title="1">var quiz models.Quiz
        query := `SELECT id, question_text, option_a, option_b, option_c, option_d, 
                          correct_answer, image_url, video_url, created_at, updated_at
                          FROM quizzes WHERE id = $1`

        err := s.db.QueryRow(query, id).Scan(
                &amp;quiz.ID,
                &amp;quiz.QuestionText,
                &amp;quiz.OptionA,
                &amp;quiz.OptionB,
                &amp;quiz.OptionC,
                &amp;quiz.OptionD,
                &amp;quiz.CorrectAnswer,
                &amp;quiz.ImageURL,
                &amp;quiz.VideoURL,
                &amp;quiz.CreatedAt,
                &amp;quiz.UpdatedAt,
        )
        if err != nil </span><span class="cov1" title="1">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        return nil, errors.New("quiz not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get quiz: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;quiz, nil</span>
}

// GetPublicQuizByID retrieves a quiz by its ID without the correct answer
func (s *QuizService) GetPublicQuizByID(id int64) (*models.QuizPublic, error) <span class="cov0" title="0">{
        quiz, err := s.GetQuizByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.QuizPublic{
                ID:           quiz.ID,
                QuestionText: quiz.QuestionText,
                OptionA:      quiz.OptionA,
                OptionB:      quiz.OptionB,
                OptionC:      quiz.OptionC,
                OptionD:      quiz.OptionD,
                ImageURL:     quiz.ImageURL,
                VideoURL:     quiz.VideoURL,
        }, nil</span>
}

// UpdateQuiz updates an existing quiz in the database
func (s *QuizService) UpdateQuiz(id int64, req models.QuizRequest) (*models.Quiz, error) <span class="cov0" title="0">{
        if id &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid quiz ID")
        }</span>

        <span class="cov0" title="0">if err := s.validateQuizRequest(req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err := s.GetQuizByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">query := `UPDATE quizzes 
                          SET question_text = $1, option_a = $2, option_b = $3, option_c = $4, 
                                  option_d = $5, correct_answer = $6, image_url = $7, video_url = $8, 
                                  updated_at = CURRENT_TIMESTAMP
                          WHERE id = $9
                          RETURNING updated_at`

        var updatedAt sql.NullTime
        err = s.db.QueryRow(query,
                req.QuestionText,
                req.OptionA,
                req.OptionB,
                req.OptionC,
                req.OptionD,
                req.CorrectAnswer,
                req.ImageURL,
                req.VideoURL,
                id,
        ).Scan(&amp;updatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update quiz: %w", err)
        }</span>

        <span class="cov0" title="0">return s.GetQuizByID(id)</span>
}

// DeleteQuiz deletes a quiz from the database
func (s *QuizService) DeleteQuiz(id int64) error <span class="cov0" title="0">{
        if id &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("invalid quiz ID")
        }</span>

        <span class="cov0" title="0">_, err := s.GetQuizByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = s.db.Exec("DELETE FROM quizzes WHERE id = $1", id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete quiz: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetQuizzes retrieves a paginated list of quizzes
func (s *QuizService) GetQuizzes(page, limit int) ([]models.Quiz, int, error) <span class="cov0" title="0">{
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * limit

        var total int
        err := s.db.QueryRow("SELECT COUNT(*) FROM quizzes").Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count quizzes: %w", err)
        }</span>

        <span class="cov0" title="0">query := `SELECT id, question_text, option_a, option_b, option_c, option_d, 
                          correct_answer, image_url, video_url, created_at, updated_at
                          FROM quizzes 
                          ORDER BY created_at DESC 
                          LIMIT $1 OFFSET $2`

        rows, err := s.db.Query(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to query quizzes: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error closing rows: %v\n", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">var quizzes []models.Quiz
        for rows.Next() </span><span class="cov0" title="0">{
                var quiz models.Quiz
                err := rows.Scan(
                        &amp;quiz.ID,
                        &amp;quiz.QuestionText,
                        &amp;quiz.OptionA,
                        &amp;quiz.OptionB,
                        &amp;quiz.OptionC,
                        &amp;quiz.OptionD,
                        &amp;quiz.CorrectAnswer,
                        &amp;quiz.ImageURL,
                        &amp;quiz.VideoURL,
                        &amp;quiz.CreatedAt,
                        &amp;quiz.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan quiz: %w", err)
                }</span>
                <span class="cov0" title="0">quizzes = append(quizzes, quiz)</span>
        }

        <span class="cov0" title="0">return quizzes, total, nil</span>
}

func (s *QuizService) validateQuizRequest(req models.QuizRequest) error <span class="cov10" title="4">{
        if req.QuestionText == "" </span><span class="cov1" title="1">{
                return errors.New("question text is required")
        }</span>
        <span class="cov8" title="3">if req.OptionA == "" || req.OptionB == "" || req.OptionC == "" || req.OptionD == "" </span><span class="cov1" title="1">{
                return errors.New("all options are required")
        }</span>
        <span class="cov5" title="2">if req.CorrectAnswer != "A" &amp;&amp; req.CorrectAnswer != "B" &amp;&amp; req.CorrectAnswer != "C" &amp;&amp; req.CorrectAnswer != "D" </span><span class="cov1" title="1">{
                return errors.New("correct answer must be A, B, C, or D")
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package services

import (
        "bytes"
        "fmt"
        "io"
        "path/filepath"

        "github.com/Tattsum/quiz/internal/models"
        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3"
)

// S3StorageService implements StorageService for AWS S3 storage
type S3StorageService struct {
        bucket   string
        region   string
        baseURL  string
        s3Client *s3.S3
}

// NewS3StorageService creates a new S3StorageService instance
func NewS3StorageService(bucket, region, baseURL string) (*S3StorageService, error) <span class="cov0" title="0">{
        sess, err := session.NewSession(&amp;aws.Config{
                Region: aws.String(region),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create AWS session: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;S3StorageService{
                bucket:   bucket,
                region:   region,
                baseURL:  baseURL,
                s3Client: s3.New(sess),
        }, nil</span>
}

// Store saves image data to S3 storage
func (s *S3StorageService) Store(imageUpload *models.ImageUpload, data []byte) error <span class="cov0" title="0">{
        key := s.generateS3Key(imageUpload.Filename)

        input := &amp;s3.PutObjectInput{
                Bucket:      aws.String(s.bucket),
                Key:         aws.String(key),
                Body:        bytes.NewReader(data),
                ContentType: aws.String(imageUpload.ContentType),
                ACL:         aws.String("public-read"),
                Metadata: map[string]*string{
                        "original-name": aws.String(imageUpload.OriginalName),
                        "width":         aws.String(fmt.Sprintf("%d", imageUpload.Width)),
                        "height":        aws.String(fmt.Sprintf("%d", imageUpload.Height)),
                },
        }

        _, err := s.s3Client.PutObject(input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload to S3: %w", err)
        }</span>

        <span class="cov0" title="0">imageUpload.Path = key
        imageUpload.URL = s.GetURL(imageUpload)

        return nil</span>
}

// GetURL returns the public URL for an uploaded image in S3
func (s *S3StorageService) GetURL(imageUpload *models.ImageUpload) string <span class="cov0" title="0">{
        if s.baseURL != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s/%s", s.baseURL, imageUpload.Path)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("https://%s.s3.%s.amazonaws.com/%s", s.bucket, s.region, imageUpload.Path)</span>
}

// Delete removes an image file from S3 storage
func (s *S3StorageService) Delete(imageUpload *models.ImageUpload) error <span class="cov0" title="0">{
        input := &amp;s3.DeleteObjectInput{
                Bucket: aws.String(s.bucket),
                Key:    aws.String(imageUpload.Path),
        }

        _, err := s.s3Client.DeleteObject(input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete from S3: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *S3StorageService) generateS3Key(filename string) string <span class="cov0" title="0">{
        subdirs := s.generateSubdirs(filename)
        return filepath.Join("images", subdirs, filename)
}</span>

func (s *S3StorageService) generateSubdirs(filename string) string <span class="cov0" title="0">{
        if len(filename) &lt; 4 </span><span class="cov0" title="0">{
                return "misc"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s/%s", filename[:2], filename[2:4])</span>
}

// CopyToStorage uploads data from a reader to S3 storage
func (s *S3StorageService) CopyToStorage(source io.Reader, imageUpload *models.ImageUpload) error <span class="cov0" title="0">{
        key := s.generateS3Key(imageUpload.Filename)

        data, err := io.ReadAll(source)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source data: %w", err)
        }</span>

        <span class="cov0" title="0">input := &amp;s3.PutObjectInput{
                Bucket:      aws.String(s.bucket),
                Key:         aws.String(key),
                Body:        bytes.NewReader(data),
                ContentType: aws.String(imageUpload.ContentType),
                ACL:         aws.String("public-read"),
                Metadata: map[string]*string{
                        "original-name": aws.String(imageUpload.OriginalName),
                        "width":         aws.String(fmt.Sprintf("%d", imageUpload.Width)),
                        "height":        aws.String(fmt.Sprintf("%d", imageUpload.Height)),
                },
        }

        _, err = s.s3Client.PutObject(input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload to S3: %w", err)
        }</span>

        <span class="cov0" title="0">imageUpload.Path = key
        imageUpload.URL = s.GetURL(imageUpload)
        imageUpload.Size = int64(len(data))

        return nil</span>
}

// HeadObject retrieves metadata for an object in S3
func (s *S3StorageService) HeadObject(imageUpload *models.ImageUpload) error <span class="cov0" title="0">{
        input := &amp;s3.HeadObjectInput{
                Bucket: aws.String(s.bucket),
                Key:    aws.String(imageUpload.Path),
        }

        result, err := s.s3Client.HeadObject(input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get object metadata: %w", err)
        }</span>

        <span class="cov0" title="0">if result.ContentLength != nil </span><span class="cov0" title="0">{
                imageUpload.Size = *result.ContentLength
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package services

import (
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/Tattsum/quiz/internal/models"
)

// StorageService defines the interface for file storage operations
type StorageService interface {
        Store(imageUpload *models.ImageUpload, data []byte) error
        GetURL(imageUpload *models.ImageUpload) string
        Delete(imageUpload *models.ImageUpload) error
}

// LocalStorageService implements StorageService for local file system storage
type LocalStorageService struct {
        uploadDir string
        baseURL   string
}

// NewLocalStorageService creates a new LocalStorageService instance
func NewLocalStorageService(uploadDir, baseURL string) *LocalStorageService <span class="cov8" title="4">{
        return &amp;LocalStorageService{
                uploadDir: uploadDir,
                baseURL:   baseURL,
        }
}</span>

// Store saves image data to local storage
func (s *LocalStorageService) Store(imageUpload *models.ImageUpload, data []byte) error <span class="cov4" title="2">{
        if err := s.ensureUploadDirExists(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create upload directory: %w", err)
        }</span>

        <span class="cov4" title="2">subdirs := s.generateSubdirs(imageUpload.Filename)
        fullDir := filepath.Join(s.uploadDir, subdirs)

        if err := os.MkdirAll(fullDir, 0o750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create subdirectories: %w", err)
        }</span>

        <span class="cov4" title="2">filePath := filepath.Join(fullDir, imageUpload.Filename)
        // #nosec G304 - imageUpload.Filename is validated by ImageService
        file, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov4" title="2">defer func() </span><span class="cov4" title="2">{
                _ = file.Close()
        }</span>()

        <span class="cov4" title="2">if _, err := file.Write(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov4" title="2">imageUpload.Path = filepath.Join(subdirs, imageUpload.Filename)
        imageUpload.URL = s.GetURL(imageUpload)

        return nil</span>
}

// GetURL returns the public URL for an uploaded image
func (s *LocalStorageService) GetURL(imageUpload *models.ImageUpload) string <span class="cov7" title="3">{
        return fmt.Sprintf("%s/uploads/images/%s", s.baseURL, imageUpload.Path)
}</span>

// Delete removes an image file from local storage
func (s *LocalStorageService) Delete(imageUpload *models.ImageUpload) error <span class="cov1" title="1">{
        filePath := filepath.Join(s.uploadDir, imageUpload.Path)

        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">if err := os.Remove(filePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (s *LocalStorageService) ensureUploadDirExists() error <span class="cov4" title="2">{
        if _, err := os.Stat(s.uploadDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return os.MkdirAll(s.uploadDir, 0o750)
        }</span>
        <span class="cov4" title="2">return nil</span>
}

func (s *LocalStorageService) generateSubdirs(filename string) string <span class="cov10" title="5">{
        if len(filename) &lt; 4 </span><span class="cov1" title="1">{
                return "misc"
        }</span>

        <span class="cov8" title="4">return fmt.Sprintf("%s/%s", filename[:2], filename[2:4])</span>
}

// CopyToStorage copies image data from source reader to local storage
func (s *LocalStorageService) CopyToStorage(source io.Reader, imageUpload *models.ImageUpload) error <span class="cov0" title="0">{
        if err := s.ensureUploadDirExists(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create upload directory: %w", err)
        }</span>

        <span class="cov0" title="0">subdirs := s.generateSubdirs(imageUpload.Filename)
        fullDir := filepath.Join(s.uploadDir, subdirs)

        if err := os.MkdirAll(fullDir, 0o750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create subdirectories: %w", err)
        }</span>

        <span class="cov0" title="0">filePath := filepath.Join(fullDir, imageUpload.Filename)
        // #nosec G304 - imageUpload.Filename is validated by ImageService
        file, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = file.Close()
        }</span>()

        <span class="cov0" title="0">size, err := io.Copy(file, source)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        <span class="cov0" title="0">imageUpload.Path = filepath.Join(subdirs, imageUpload.Filename)
        imageUpload.URL = s.GetURL(imageUpload)
        imageUpload.Size = size

        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
